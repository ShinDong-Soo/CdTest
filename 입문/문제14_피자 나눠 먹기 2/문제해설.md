
## 🍕 문제 요약

* 피자 1판 = **6조각**
* `n`명이 **남김없이** **모두 같은 수의 조각**을 먹어야 함
* 최소 **몇 판**을 시켜야 하는가?

---

## 🧠 핵심 아이디어 (수학)

피자를 `x`판 시키면 총 조각 수는 `6x` 입니다.
모두 같은 수의 조각을 먹고 남김이 없으려면:

> **`6x`가 `n`으로 나누어떨어져야 함** (즉, `6x % n == 0`)

이때 **가장 작은 x**를 구하는 것이 목표입니다.

수학적으로,

* `x = lcm(6, n) / 6`
* 그런데 `lcm(a, b) = a * b / gcd(a, b)` 이므로,
* `x = (6 * n / gcd(6, n)) / 6 = n / gcd(6, n)`

👉 **정답 = `n / gcd(6, n)`**

---

## ✅ 결론 공식

> **최소 판 수 = `n / gcd(6, n)`**

(여기서 `gcd`는 최대공약수)

---

## 💻 C# 기본 코드

```csharp
public class Solution {
    public int solution(int n) {
        return n / Gcd(n, 6);
    }

    // 유클리드 호제법
    private int Gcd(int a, int b) {
        while (b != 0) {
            int t = b;
            b = a % b;
            a = t;
        }
        return a;
    }
}
```

---

## 🔄 대안(반복으로 직관 접근)

수학 공식을 몰라도, “가장 작은 x”를 직접 찾는 방법:

```csharp
public int solution(int n) {
    int x = 1;
    while ((6 * x) % n != 0) {
        x++;
    }
    return x;
}
```

* `(6 * x)`가 `n`으로 나누어떨어질 때까지 `x`를 1씩 증가
* 입력 범위가 작을 때(1\~100)도 충분히 빠름
  (다만, 수학 공식이 더 깔끔하고 효율적)

---

## 🧪 예시 검증

* `n = 6` → `gcd(6,6)=6` → `6/6=1` → **1판**
* `n = 10` → `gcd(10,6)=2` → `10/2=5` → **5판** (총 30조각, 10명이 3조각씩)
* `n = 4` → `gcd(4,6)=2` → `4/2=2` → **2판** (총 12조각, 4명이 3조각씩)

---

## 📝 노션 요약 템플릿

**문제:** 1판 6조각, n명이 남김없이 같은 수의 조각을 먹도록 최소 판 수 구하기
**조건:** `6 * x`가 `n`으로 나누어떨어져야 함
**결론:** `x = n / gcd(6, n)`
**코드:**

```csharp
public int solution(int n) => n / Gcd(n, 6);
```

**Gcd:** 유클리드 호제법 사용
**검증:** n=6→1, n=10→5, n=4→2

---
---


## 🧠 유클리드 호제법이란?

> 두 정수 `a, b (a ≥ b)`의 \*\*최대공약수(GCD)\*\*를 빠르게 구하는 알고리즘.
> 핵심 원리: **`GCD(a, b) = GCD(b, a % b)`**, 그리고 `b == 0`이면 답은 `a`.

### 작동 원리 (직관)

* 큰 수 `a`를 작은 수 `b`로 나누면 `a = b*q + r` (나머지 `r`)
* `a`와 `b`의 공약수는 **나머지 `r`에도 동일**하게 적용되므로
  최대공약수도 그대로 보존: `GCD(a, b) = GCD(b, r)`

### 예)

`GCD(30, 18)`

* 30 % 18 = 12 → `GCD(30,18) = GCD(18,12)`
* 18 % 12 = 6  → `GCD(18,12) = GCD(12,6)`
* 12 % 6 = 0   → `GCD(12,6) = 6`
* 답: **6**

---

## 🍕 피자 (2) 문제에 유클리드 호제법을 쓰는 이유

* 피자 1판은 **6조각**. `x`판을 시키면 총 조각은 `6x`.
* `n`명이 **남김없이** **같은 수**의 조각을 먹으려면
  `6x`가 `n`으로 나누어떨어져야 함 → **`6x % n == 0`**.
* 이 조건을 만족하는 **가장 작은 x**는 수학적으로
  `x = lcm(6, n) / 6` (lcm = 최소공배수)
* 최소공배수는 `lcm(a, b) = a * b / gcd(a, b)`
* 따라서,

  ```
  x = (6 * n / gcd(6, n)) / 6
    = n / gcd(6, n)
  ```
* 즉, **정답 = `n / gcd(6, n)`**
  → 이때 `gcd(6, n)`을 **유클리드 호제법**으로 빠르게 구하면 됨.

---

## ✅ C# 구현 (반복/재귀)

### 반복(iterative) 버전 (권장)

```csharp
int Gcd(int a, int b)
{
    while (b != 0)
    {
        int t = b;
        b = a % b;
        a = t;
    }
    return a;
}
```

### 재귀(recursive) 버전

```csharp
int Gcd(int a, int b)
{
    return b == 0 ? a : Gcd(b, a % b);
}
```

### 최종 해답 함수

```csharp
public int solution(int n)
{
    return n / Gcd(n, 6);
}
```

---

## 🔍 예시로 검증

* `n = 6`
  `gcd(6,6)=6` → `6/6=1` → **1판**

* `n = 10`
  `gcd(10,6)=2` → `10/2=5` → **5판** (총 30조각, 10명이 3조각씩)

* `n = 4`
  `gcd(4,6)=2` → `4/2=2` → **2판** (총 12조각, 4명이 3조각씩)

---

## 🧩 복잡도 & 장점

* 유클리드 호제법 시간복잡도: **O(log min(a, b))** (매우 빠름)
* 반복 버전은 **스택 사용 X**(안전), 재귀는 **코드가 간결**
* 이 문제의 입력 범위(1\~100)에서는 둘 다 충분히 빠름

---

## 🌱 응용/일반화

* **슬라이스가 `S`조각인 피자**라면?
  최소 판 수 = **`n / gcd(n, S)`**
* **최소공배수 구하기**:
  `lcm(a,b) = a * b / gcd(a,b)`
  (오버플로우 주의: 큰 수라면 `long` 사용)

---

## 📝 노션 요약 템플릿

**핵심:** `GCD(a,b) = GCD(b, a%b)` / `b==0 → a`
**피자(2) 결론:** `x = n / gcd(6, n)`
**C# 코드:**

```csharp
int Gcd(int a, int b) { while (b != 0) { int t=b; b=a%b; a=t; } return a; }
public int solution(int n) => n / Gcd(n, 6);
```

**검증:** n=6→1, n=10→5, n=4→2

---
---

## 🔁 전체 흐름 먼저 보기

```csharp
// 유클리드 호제법 함수
int Gcd(int a, int b)
{
    while (b != 0)
    {
        int t = b;
        b = a % b;
        a = t;
    }
    return a; // ✅ 여기서 a는 '최대공약수 GCD'가 된다!
}

// 최종 정답을 반환하는 메서드
public int solution(int n)
{
    return n / Gcd(n, 6); // ✅ 이 부분이 핵심!
}
```

---

## 💡 전체 흐름을 간단히 말하면

1. `Gcd(n, 6)` → \*\*n과 6의 최대공약수(GCD)\*\*를 구함. (최대공약수는 **서로 나누어지는 가장 큰 수**)
2. 그 최대공약수는 `Gcd()` 함수 내부에서 `a`라는 변수에 저장됨.
3. `return a;` → 즉, **최대공약수 GCD를 반환**함.
4. 그 반환된 GCD 값이 `n / Gcd(n, 6)`에 들어가서,
5. **n을 최대공약수로 나눈 값**을 최종적으로 반환함.

---

## 🔍 예시로 흐름 추적하기

### 예: `n = 10`

```csharp
solution(10) → return 10 / Gcd(10, 6);
```

#### Gcd(10, 6)

* 10 % 6 = 4 → a = 6, b = 4
* 6 % 4 = 2 → a = 4, b = 2
* 4 % 2 = 0 → a = 2, b = 0 → **return 2**

✅ 즉, `Gcd(10, 6)` → 2 → `n / Gcd(n, 6)` → `10 / 2` → **5**

---

## 🎯 요약: 핵심 연결 구조

| 순서 | 함수 내용           | 결과        | 역할                              |
| -- | --------------- | --------- | ------------------------------- |
| ①  | `Gcd(n, 6)`     | 최대공약수 `a` | 서로 나누어지는 가장 큰 수                 |
| ②  | `return a`      | GCD 값 반환  | `solution` 함수에서 사용됨             |
| ③  | `n / Gcd(n, 6)` | 최소 판 수    | **남기지 않고 똑같이 나누기 위한 피자 판 수** 계산 |

---

## 🧠 비유로 쉽게 설명하면

* `Gcd()` 함수는 **"둘이 공평하게 나누기 위해 가장 큰 단위"를 찾아주는 도구**.
* `return a`는 그 도구로 찾은 **"최대 단위"**.
* `n / Gcd(n, 6)`는 그 단위만큼 **몇 묶음이 필요한지 계산**하는 공식이에요.
