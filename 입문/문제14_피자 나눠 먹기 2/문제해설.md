
## 🍕 문제 요약

* 피자 1판 = **6조각**
* `n`명이 **남김없이** **모두 같은 수의 조각**을 먹어야 함
* 최소 **몇 판**을 시켜야 하는가?

---

## 🧠 핵심 아이디어 (수학)

피자를 `x`판 시키면 총 조각 수는 `6x` 입니다.
모두 같은 수의 조각을 먹고 남김이 없으려면:

> **`6x`가 `n`으로 나누어떨어져야 함** (즉, `6x % n == 0`)

이때 **가장 작은 x**를 구하는 것이 목표입니다.

수학적으로,

* `x = lcm(6, n) / 6`
* 그런데 `lcm(a, b) = a * b / gcd(a, b)` 이므로,
* `x = (6 * n / gcd(6, n)) / 6 = n / gcd(6, n)`

👉 **정답 = `n / gcd(6, n)`**

---

## ✅ 결론 공식

> **최소 판 수 = `n / gcd(6, n)`**

(여기서 `gcd`는 최대공약수)

---

## 💻 C# 기본 코드

```csharp
public class Solution {
    public int solution(int n) {
        return n / Gcd(n, 6);
    }

    // 유클리드 호제법
    private int Gcd(int a, int b) {
        while (b != 0) {
            int t = b;
            b = a % b;
            a = t;
        }
        return a;
    }
}
```

---

## 🔄 대안(반복으로 직관 접근)

수학 공식을 몰라도, “가장 작은 x”를 직접 찾는 방법:

```csharp
public int solution(int n) {
    int x = 1;
    while ((6 * x) % n != 0) {
        x++;
    }
    return x;
}
```

* `(6 * x)`가 `n`으로 나누어떨어질 때까지 `x`를 1씩 증가
* 입력 범위가 작을 때(1\~100)도 충분히 빠름
  (다만, 수학 공식이 더 깔끔하고 효율적)

---

## 🧪 예시 검증

* `n = 6` → `gcd(6,6)=6` → `6/6=1` → **1판**
* `n = 10` → `gcd(10,6)=2` → `10/2=5` → **5판** (총 30조각, 10명이 3조각씩)
* `n = 4` → `gcd(4,6)=2` → `4/2=2` → **2판** (총 12조각, 4명이 3조각씩)

---

## 📝 노션 요약 템플릿

**문제:** 1판 6조각, n명이 남김없이 같은 수의 조각을 먹도록 최소 판 수 구하기
**조건:** `6 * x`가 `n`으로 나누어떨어져야 함
**결론:** `x = n / gcd(6, n)`
**코드:**

```csharp
public int solution(int n) => n / Gcd(n, 6);
```

**Gcd:** 유클리드 호제법 사용
**검증:** n=6→1, n=10→5, n=4→2

---
---

좋아요! \*\*유클리드 호제법(Euclidean Algorithm)\*\*을 이용해 \*피자 나눠 먹기 (2)\*를 푸는 법을 **개념 → 이유 → 구현 → 예시 → 응용** 순서로 자세히 정리해드릴게요. (노션에 그대로 옮겨 적기 좋게 구성했습니다.)

---

## 🧠 유클리드 호제법이란?

> 두 정수 `a, b (a ≥ b)`의 \*\*최대공약수(GCD)\*\*를 빠르게 구하는 알고리즘.
> 핵심 원리: **`GCD(a, b) = GCD(b, a % b)`**, 그리고 `b == 0`이면 답은 `a`.

### 작동 원리 (직관)

* 큰 수 `a`를 작은 수 `b`로 나누면 `a = b*q + r` (나머지 `r`)
* `a`와 `b`의 공약수는 **나머지 `r`에도 동일**하게 적용되므로
  최대공약수도 그대로 보존: `GCD(a, b) = GCD(b, r)`

### 예)

`GCD(30, 18)`

* 30 % 18 = 12 → `GCD(30,18) = GCD(18,12)`
* 18 % 12 = 6  → `GCD(18,12) = GCD(12,6)`
* 12 % 6 = 0   → `GCD(12,6) = 6`
* 답: **6**

---

## 🍕 피자 (2) 문제에 유클리드 호제법을 쓰는 이유

* 피자 1판은 **6조각**. `x`판을 시키면 총 조각은 `6x`.
* `n`명이 **남김없이** **같은 수**의 조각을 먹으려면
  `6x`가 `n`으로 나누어떨어져야 함 → **`6x % n == 0`**.
* 이 조건을 만족하는 **가장 작은 x**는 수학적으로
  `x = lcm(6, n) / 6` (lcm = 최소공배수)
* 최소공배수는 `lcm(a, b) = a * b / gcd(a, b)`
* 따라서,

  ```
  x = (6 * n / gcd(6, n)) / 6
    = n / gcd(6, n)
  ```
* 즉, **정답 = `n / gcd(6, n)`**
  → 이때 `gcd(6, n)`을 **유클리드 호제법**으로 빠르게 구하면 됨.

---

## ✅ C# 구현 (반복/재귀)

### 반복(iterative) 버전 (권장)

```csharp
int Gcd(int a, int b)
{
    while (b != 0)
    {
        int t = b;
        b = a % b;
        a = t;
    }
    return a;
}
```

### 재귀(recursive) 버전

```csharp
int Gcd(int a, int b)
{
    return b == 0 ? a : Gcd(b, a % b);
}
```

### 최종 해답 함수

```csharp
public int solution(int n)
{
    return n / Gcd(n, 6);
}
```

---

## 🔍 예시로 검증

* `n = 6`
  `gcd(6,6)=6` → `6/6=1` → **1판**

* `n = 10`
  `gcd(10,6)=2` → `10/2=5` → **5판** (총 30조각, 10명이 3조각씩)

* `n = 4`
  `gcd(4,6)=2` → `4/2=2` → **2판** (총 12조각, 4명이 3조각씩)

---

## 🧩 복잡도 & 장점

* 유클리드 호제법 시간복잡도: **O(log min(a, b))** (매우 빠름)
* 반복 버전은 **스택 사용 X**(안전), 재귀는 **코드가 간결**
* 이 문제의 입력 범위(1\~100)에서는 둘 다 충분히 빠름

---

## 🌱 응용/일반화

* **슬라이스가 `S`조각인 피자**라면?
  최소 판 수 = **`n / gcd(n, S)`**
* **최소공배수 구하기**:
  `lcm(a,b) = a * b / gcd(a,b)`
  (오버플로우 주의: 큰 수라면 `long` 사용)

---

## 📝 노션 요약 템플릿

**핵심:** `GCD(a,b) = GCD(b, a%b)` / `b==0 → a`
**피자(2) 결론:** `x = n / gcd(6, n)`
**C# 코드:**

```csharp
int Gcd(int a, int b) { while (b != 0) { int t=b; b=a%b; a=t; } return a; }
public int solution(int n) => n / Gcd(n, 6);
```

**검증:** n=6→1, n=10→5, n=4→2
