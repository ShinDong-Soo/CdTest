

## ✅ \[C# 기초 수학] 분수의 덧셈 후 기약분수 구하기

---

### 📘 문제 요약

* 입력: 두 개의 분수

  * 첫 번째: `numer1 / denom1`
  * 두 번째: `numer2 / denom2`
* 목표: 두 분수의 합을 **기약 분수** 형태로 구하고 `[분자, 분모]` 형태로 반환

---

### 🧠 문제 해결 사고 순서

| 단계 | 질문              | 설명                                               |
| -- | --------------- | ------------------------------------------------ |
| 1  | 분수 덧셈은 어떻게 하나요? | 두 분수의 **공통 분모**를 만든 뒤 분자끼리 더한다                   |
| 2  | 분모는 어떻게 맞추나요?   | `공통 분모 = denom1 * denom2` (최소공배수로 해도 되지만 곱해도 가능) |
| 3  | 기약 분수는 어떻게 만들죠? | \*\*분자와 분모의 최대공약수(GCD)\*\*로 나눠서 약분               |
| 4  | GCD는 어떻게 구하나요?  | `유클리드 호제법` 사용 (재귀 또는 반복문)                        |

---

### ✨ 수학 공식

```text
a/b + c/d = (a*d + c*b) / (b*d)
```

---

### 🧩 예제 계산

#### 예제 1: 1/2 + 3/4

* 공통 분모: 2 × 4 = 8
* 분자 계산: (1×4 + 3×2) = 4 + 6 = 10
* 분수: 10/8
* 최대공약수(GCD): 2
* 기약 분수: 10/8 → 5/4 → `[5, 4]`

---

### ✅ C# 최종 코드 예시

```csharp
public class Solution {
    public int[] solution(int numer1, int denom1, int numer2, int denom2) {
        int numerator = numer1 * denom2 + numer2 * denom1;
        int denominator = denom1 * denom2;
        int gcd = GCD(numerator, denominator);

        return new int[] { numerator / gcd, denominator / gcd };
    }

    // 최대공약수 구하는 함수 (유클리드 호제법)
    private int GCD(int a, int b) {
        while (b != 0) {
            int temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }
}
```

---

### 💡 핵심 개념 요약 (Notion용)

* **분수 덧셈**
  `a/b + c/d = (a*d + c*b) / (b*d)`
* **기약 분수 만들기**
  최대공약수(GCD)로 분자/분모를 나눈다
* **유클리드 호제법**
  `GCD(a, b) = GCD(b, a % b)`
  `b == 0`이면 `a`가 최대공약수

---

### 🧪 입출력 확인

| 입력         | 계산                             | 출력       |
| ---------- | ------------------------------ | -------- |
| 1, 2, 3, 4 | (1×4 + 3×2)/(2×4) = 10/8 → 5/4 | \[5, 4]  |
| 9, 2, 1, 3 | (9×3 + 1×2)/(2×3) = 29/6 → 기약  | \[29, 6] |

---

### 📌 초보자 체크리스트

* [x] 분수 덧셈 공식을 기억하고 있는가?
* [x] 최대공약수(GCD) 함수 작성 가능?
* [x] 정수 배열로 `[분자, 분모]` 반환하는 법 숙지?

---
---

아래는 이미지 속 코드:

```csharp
int GCD(int a, int b) {
    while (b != 0) {
        int temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}
```

이 코드는 \*\*유클리드 호제법(나눗셈 방식)\*\*을 사용해서 \*\*두 수 a, b의 최대공약수(GCD)\*\*를 구합니다. 초보자도 이해할 수 있도록 **한 줄씩 자세히 설명**드릴게요.

---

## 🔍 한 줄씩 설명

---

### `int GCD(int a, int b)`

* `a`와 `b`라는 두 정수를 받아서
* 이 둘의 \*\*최대공약수(GCD)\*\*를 계산하는 함수입니다.

---

### `while (b != 0)`

* **b가 0이 될 때까지 반복**합니다.
* 유클리드 호제법의 원리는:
  `GCD(a, b)`는 `GCD(b, a % b)`와 같다는 수학 공식에 기반합니다.

---

### `int temp = b;`

* `b`의 현재 값을 `temp`에 저장해 둡니다.
* 이유: 잠시 뒤 `b`가 바뀌기 때문에, 지금의 `b` 값을 다음 단계에서 `a`로 넘기기 위해 **백업**해 놓는 거예요.

---

### `b = a % b;`

* `a`를 `b`로 나눈 **나머지**를 `b`에 저장합니다.
* 이 과정은 **큰 수(a)를 작은 수(b)로 나눈 나머지**를 다음 반복에서 사용할 준비를 하는 것.
* 핵심 공식: `GCD(a, b) == GCD(b, a % b)` 를 적용한 거예요.

---

### `a = temp;`

* 아까 백업해둔 `b` 값을 `a`에 넣습니다.
* 즉, **기존의 작은 수를 큰 수 자리(a)에 옮겨놓는 작업**이에요.

---

### 💡 반복이 끝날 때까지

* 이 과정을 `b가 0이 될 때까지` 계속합니다.
* 결국 `b == 0`일 때 반복이 멈추고,
* **그 순간의 `a`가 최대공약수**가 됩니다.

---

### `return a;`

* 계산이 끝난 후, 최종적으로 최대공약수인 `a`를 반환합니다.

---

## 📌 예시로 직접 보기

입력: `GCD(12, 18)`

| a                                         | b  | a % b | temp |
| ----------------------------------------- | -- | ----- | ---- |
| 12                                        | 18 | 12    | 18   |
| 18                                        | 12 | 6     | 12   |
| 12                                        | 6  | 0     | 6    |
| → `b == 0`이 되었을 때 `a == 6` → 최대공약수는 **6** |    |       |      |

---

## ✅ 요약 정리 (Notion용)

* **유클리드 호제법**: `GCD(a, b) = GCD(b, a % b)`
* **while문**을 통해 `b가 0이 될 때까지` a, b를 바꾸며 반복
* `b == 0`이면 `a`가 최대공약수
* **빠르고 효율적**, 대부분 언어에서 이 방식 사용

