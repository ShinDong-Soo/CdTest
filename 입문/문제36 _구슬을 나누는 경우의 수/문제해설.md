좋습니다 👍
이번에는 **완전 초보자 눈높이**에서, “왜 이런 결론에 도달했는지” 하나씩 풀어서 정리해드릴게요.
노션에 그대로 옮겨두면 공부할 때 큰 도움이 될 거예요.

---

# 🔵 구슬을 나누는 경우의 수 (C#) — 초보자용 풀이 노트

## 1) 문제 이해

* 서로 다른 구슬이 `balls` 개 있다.
* 이 중에서 `share` 개를 **고르는 방법의 수**를 구하는 문제다.
* “고르는 순서”는 중요하지 않다.
  예: {A,B} 와 {B,A} 는 같은 경우.

👉 이런 문제를 **조합(Combination)** 문제라고 한다.

---

## 2) 작은 예시로 감 잡기

* 구슬이 3개(A,B,C), 그중 2개를 고른다.

  * (A,B), (A,C), (B,C) → 총 3가지.
* 구슬이 5개(A,B,C,D,E), 그중 3개를 고른다.

  * (A,B,C), (A,B,D), … (D,E,C) → 총 10가지.

👉 이게 바로 `C(3,2)=3`, `C(5,3)=10` 이라는 결과다.

---

## 3) 수학 공식

조합의 개수는 수학적으로 이렇게 계산한다:

$$
C(n,k) = \frac{n!}{k!(n-k)!}
$$

* `n!` = 1 × 2 × 3 × … × n (팩토리얼)
* `C(5,3)` = 5! / (3! × 2!)
  \= (5×4×3×2×1) / ((3×2×1) × (2×1))
  \= 120 / (6×2) = 10

👉 공식만 알면 어떤 경우든 계산할 수 있다.

---

## 4) C#에서 주의할 점

* `n!` 같은 값은 숫자가 너무 커진다.
  예: 30! = 엄청나게 큰 수 → `int`나 `long`으로 표현 불가.
* 그래서 C#에서는 **BigInteger** 라는 “큰 수 전용 자료형”을 사용해야 한다.

  * `System.Numerics` 네임스페이스 안에 있다.

---

## 5) 더 효율적인 계산 방법

공식을 그대로 쓰면 **팩토리얼**을 먼저 구해야 해서 값이 너무 커진다.
👉 대신 이렇게 계산하는 게 안전하다:

$$
C(n,k) = \frac{(n-k+1)}{1} × \frac{(n-k+2)}{2} × … × \frac{n}{k}
$$

* 예: C(5,3)

  * \= (5-3+1)/1 × (5-3+2)/2 × (5-3+3)/3
  * \= (3/1) × (4/2) × (5/3)
  * \= 3 × 2 × (5/3) = 10

👉 이렇게 하면 중간에 큰 수가 안 나오고, 바로 나눠 떨어져서 계산이 깔끔하다.

---

## 6) C# 코드 (초보자용, 주석 많게)

```csharp
using System;
using System.Numerics; // BigInteger 사용하기 위해 필요

public class Solution
{
    public string solution(int balls, int share)
    {
        int n = balls;
        int k = share;

        // nCk = nC(n-k) 이므로 더 작은 쪽을 사용하면 계산이 더 적다
        k = Math.Min(k, n - k);

        BigInteger result = BigInteger.One; // 결과 저장 (처음은 1)

        // 곱셈식 공식: (n-k+1)/1 × (n-k+2)/2 × ... × (n)/k
        for (int i = 1; i <= k; i++)
        {
            result *= (n - k + i); // 분자 곱하기
            result /= i;           // 분모 나누기 (항상 나누어 떨어짐)
        }

        return result.ToString(); // 결과를 문자열로 반환
    }
}
```

---

## 7) 테스트 해보기

* `solution(3,2)` → `3`
* `solution(5,3)` → `10`
* `solution(10,0)` → `1` (아무것도 안 고르는 경우는 1가지뿐)
* `solution(10,10)` → `1` (전부 고르는 경우도 1가지뿐)

---

## 8) 자주 하는 실수

* `int`나 `long`으로 풀려고 하면 오버플로 발생.
* `for`문에서 분자만 곱하고 나누기 안 하면 수가 커져서 망가짐.
* `"2"` 같은 문자열이 아니라 `'2'` 문자와 숫자를 헷갈리는 경우.

---

## 9) 한 화면 요약

* **문제**: 조합 C(n,k) 구하기
* **핵심**: 팩토리얼 대신 곱셈식 공식 사용 + BigInteger
* **복잡도**: O(k) → 빠르고 안전
* **코드 포인트**: `System.Numerics.BigInteger`, 분자/분모 순서대로 계산

---

👉 이렇게 정리해 두면 초보자도 “아, 큰 수 때문에 BigInteger가 필요하구나 → 팩토리얼 말고 곱하면서 나누는 게 안전하구나” 하고 이해할 수 있습니다.

---
---

좋습니다 👍
이번에는 **팩토리얼을 직접 계산해서 조합을 구하는 방식**을 설명해드릴게요.
(효율은 떨어지지만 초보자 눈에는 “공식 그대로 구현”이라 더 직관적입니다.)

---

# 🔵 구슬 나누기 — 팩토리얼 버전 (C#)

## 1) 접근 방법

* 조합 공식:

  $$
  C(n,k) = \frac{n!}{k!(n-k)!}
  $$
* 그대로 **팩토리얼 함수**를 만들어서 대입하면 된다.

👉 다만 `n!` 값은 매우 커지므로 **BigInteger**를 사용해야 안전하다.

---

## 2) C# 코드 (팩토리얼 직접 계산)

```csharp
using System;
using System.Numerics; // BigInteger 사용을 위해 필요

public class Solution
{
    // 팩토리얼 계산 함수
    private BigInteger Factorial(int x)
    {
        BigInteger result = BigInteger.One;
        for (int i = 1; i <= x; i++)
        {
            result *= i;
        }
        return result;
    }

    public string solution(int balls, int share)
    {
        // 공식: n! / (k! * (n-k)!)
        BigInteger numerator = Factorial(balls);             // n!
        BigInteger denominator = Factorial(share) * Factorial(balls - share); // k! * (n-k)!

        BigInteger result = numerator / denominator; // 정수로 나눠짐
        return result.ToString();
    }
}
```

---

## 3) 예시 실행

* `solution(3,2)` → `3`
* `solution(5,3)` → `10`
* `solution(30,15)` → 정상 동작 (BigInteger 덕분)

---

## 4) 장단점

✅ **장점**

* 조합 공식을 그대로 코드로 옮겨 이해하기 쉽다.
* 팩토리얼 함수 자체를 따로 공부할 수 있다.

❌ **단점**

* 중간 계산인 `n!`이 불필요하게 크다. (30! 같은 값은 자리수가 30자 이상)
* 비효율적이라 실제 코딩테스트에서는 잘 쓰지 않는다.

👉 그래서 실무/테스트에서는 **곱하면서 나누는 방식**이 더 효율적이다.
👉 하지만 **초보자 입장에서는 “공식 → 코드” 흐름 이해용**으로 매우 좋다.

---

## 5) 요약

* **팩토리얼 버전**: 직관적이지만 비효율적 → 학습용
* **곱셈식 버전**: 효율적이고 안정적 → 실전용

---
---

좋습니다 👍
노션에 바로 옮겨둘 수 있도록 **표 형태**로 “팩토리얼 버전 vs 곱셈식 버전”을 비교 정리해드릴게요.

---

# 🔵 구슬 나누기 (조합 C(n,k)) — 구현 방식 비교

| 구분         | 팩토리얼 버전                                                                                                                                              | 곱셈식 버전                                                                                        |
| ---------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------- |
| **아이디어**   | 조합 공식 그대로 구현<br>→ `C(n,k) = n! / (k!(n-k)!)`                                                                                                         | 중간에 커지는 팩토리얼을 피하고,<br>곱하면서 나눠서 계산                                                             |
| **필요한 함수** | `Factorial(int x)`                                                                                                                                   | 없음 (for문 안에서 직접 곱셈/나눗셈)                                                                       |
| **코드 예시**  | `csharp<br>BigInteger numerator = Factorial(n);<br>BigInteger denominator = Factorial(k) * Factorial(n-k);<br>result = numerator / denominator;<br>` | `csharp<br>for (int i=1; i<=k; i++) {<br>    result *= (n-k+i);<br>    result /= i;<br>}<br>` |
| **장점**     | - 수학 공식을 그대로 옮겨 이해하기 쉽다<br>- 초보자가 “조합” 개념을 직관적으로 배우기 좋다                                                                                              | - 중간 값이 커지지 않아 효율적<br>- 반복 횟수가 적고 빠르다                                                         |
| **단점**     | - 중간에 30! 같은 큰 수가 발생<br>- BigInteger 없으면 불가능<br>- 비효율적                                                                                               | - 코드가 약간 낯설 수 있음<br>- 수학 공식 이해가 조금 필요                                                         |
| **복잡도**    | O(n) (팩토리얼 계산 포함)                                                                                                                                    | O(k) (반복 횟수 훨씬 적음)                                                                            |
| **사용 추천**  | - 공부/학습용<br>- 조합 공식에 익숙해지기                                                                                                                           | - 실전 코딩테스트용<br>- 효율/안정성이 필요할 때                                                                |

---

## ✅ 정리

* **초보자 학습용**: 팩토리얼 버전 (공식 그대로라 직관적)
* **실전/코테용**: 곱셈식 버전 (효율적이고 BigInteger 안전 활용)
* 두 버전을 모두 구현해보면 **“공식 → 코드 → 최적화” 과정**을 자연스럽게 이해할 수 있다.
