

## ✅ 문제 요약

* **목표**: 배열에서 \*\*가장 많이 등장한 숫자(최빈값)\*\*를 찾는다.
* **조건**: 최빈값이 여러 개면 `-1`을 반환한다.

---

## 🧠 초보자가 생각해야 할 흐름

### 1단계: 등장 횟수 세기

* 숫자들이 몇 번 나왔는지를 \*\*Dictionary\<int, int>\*\*를 이용해 기록

### 2단계: 가장 많이 나온 횟수 찾기

* 등장 횟수 중에서 \*\*가장 큰 값(최댓값)\*\*을 찾는다

### 3단계: 최댓값과 같은 숫자가 몇 개인지 확인

* 하나면 그 숫자가 최빈값
* 여러 개면 최빈값이 여러 개 → `-1` 반환

---

## 🧾 예시 코드 (초보자용)

```csharp
using System;
using System.Collections.Generic;
using System.Linq;

public class Solution {
    public int solution(int[] array) {
        Dictionary<int, int> counts = new Dictionary<int, int>();

        // 1단계: 숫자 등장 횟수 세기
        foreach (int num in array) {
            if (!counts.ContainsKey(num)) counts[num] = 0;
            counts[num]++;
        }

        // 2단계: 가장 많이 나온 횟수
        int maxCount = counts.Values.Max();

        // 3단계: maxCount를 가진 숫자가 몇 개인지 확인
        var maxItems = counts.Where(pair => pair.Value == maxCount).ToList();

        if (maxItems.Count > 1) return -1; // 최빈값 여러 개
        return maxItems[0].Key; // 최빈값 하나
    }
}
```

---

## 📝 노션 정리 예시

### ✅ 최빈값 구하기 – C# 풀이 흐름 정리

#### 🎯 목표

* 배열에서 가장 자주 등장한 숫자(최빈값)를 찾는다.
* **단, 최빈값이 여러 개면 -1 반환**

---

### 💡 풀이 순서

| 단계 | 설명                                 | 사용 도구                 |
| -- | ---------------------------------- | --------------------- |
| 1  | 각 숫자의 등장 횟수를 센다                    | Dictionary\<int, int> |
| 2  | 등장 횟수 중 가장 큰 값을 찾는다                | `counts.Values.Max()` |
| 3  | 가장 많이 등장한 숫자가 여러 개면 `-1`, 아니면 그 숫자 | `Where`, `ToList`     |

---

### 🔍 예제 분석

```csharp
array = [1, 2, 3, 3, 3, 4]
→ 1: 1번, 2: 1번, 3: 3번, 4: 1번
→ maxCount = 3 → 3을 가진 숫자는 1개 → 결과: 3
```

---

### ✅ 핵심 문법 정리

* `Dictionary<int, int>`: 숫자별 등장 횟수 기록
* `Max()`: 최대값 찾기
* `Where(condition)`: 조건에 맞는 데이터만 필터링
* `Count`: 개수 확인

---
---

이 한 줄은 **LINQ**로 `Dictionary<int,int> counts`에서 **최빈도(=maxCount)와 같은 빈도를 가진 항목들만** 뽑아 **리스트**로 만드는 코드예요.

```csharp
var maxItems = counts.Where(pair => pair.Value == maxCount).ToList();
```

아래에 구성요소별로 풀어서 설명할게요.

---

## 1) `counts`

* 타입: `Dictionary<int, int>`
* 의미: `키` = 값(숫자), `값` = 그 숫자의 등장 횟수(빈도)

## 2) `Where(pair => pair.Value == maxCount)`

* **LINQ 필터** 연산.
* `pair`의 타입은 `KeyValuePair<int,int>`

  * `pair.Key` → 숫자 자체
  * `pair.Value` → 그 숫자의 **등장 횟수**
* 람다식 `pair => pair.Value == maxCount`

  * **조건**: 등장 횟수가 `maxCount`(가장 큰 빈도)와 같은 항목만 골라라.

즉, `counts`에서 **최대 빈도를 가진 (숫자, 빈도) 쌍들만** 남깁니다.

## 3) `.ToList()`

* `Where` 결과(지연 평가되는 `IEnumerable<…>`)를 **즉시 실행하여 `List<...>`로 물리화**.
* 왜 `List`로 바꾸나?

  * **개수**를 쉽게 보려면 `maxItems.Count`가 편함.
  * 같은 시퀀스를 **여러 번 순회**할 때 안전/효율적.
  * 이후 인덱스 접근이 필요할 수도 있음 (`maxItems[0]` 등).

---

## 전체 흐름 (문맥 포함 예시)

```csharp
// 1) 각 숫자 빈도 계산 후…
int maxCount = counts.Values.Max();              // 가장 큰 빈도
var maxItems = counts.Where(p => p.Value == maxCount).ToList();  // 그 빈도를 가진 항목들

if (maxItems.Count > 1) return -1;               // 최빈값 여러 개
return maxItems[0].Key;                          // 유일한 최빈값의 숫자
```

---

## 작동 예시

`array = [1,2,3,3,3,4]`

* counts = { 1:1, 2:1, 3:3, 4:1 }
* `maxCount = 3`
* `Where(p => p.Value == 3)` → `{ (3,3) }`
* `maxItems = [(Key=3, Value=3)]`
* `maxItems.Count == 1` → 최빈값은 `3`

`array = [1,1,2,2]`

* counts = { 1:2, 2:2 }
* `maxCount = 2`
* `maxItems = [(1,2), (2,2)]`
* `maxItems.Count == 2` → 최빈값 여러 개 → `-1`

---

## 필요 네임스페이스

```csharp
using System.Linq; // Where, Max, ToList 등을 쓰려면 꼭 필요
```

---

## 시간/공간 복잡도 (감각)

* `Where`는 **O(n)** (n = 서로 다른 숫자 개수)
* `ToList`는 필터된 만큼 복사 → **O(k)** (k = 최빈도 항목 수)

---

### 한 줄 요약

> **최대 빈도 `maxCount`를 가진 (숫자, 빈도) 쌍들만 골라 `List`로 만든 것.**
> 이후 `Count`로 “여러 개인지”를 판단하거나, `maxItems[0].Key`로 “그 숫자”를 꺼내 사용합니다.

---
---

좋습니다 👍
`Where`는 C# LINQ에서 **데이터를 조건에 맞게 필터링**하는 메서드입니다.
SQL의 `WHERE` 절과 같은 개념이라고 생각하면 이해가 쉽습니다.

---

## 1. `Where`의 기본 개념

**정의**

> 컬렉션(배열, 리스트, 딕셔너리 등)에서 **조건을 만족하는 요소만** 골라서 새로운 시퀀스를 반환합니다.

**형식**

```csharp
IEnumerable<T> Where(Func<T, bool> predicate)
```

* `predicate`: 각 요소에 대해 `true` 또는 `false`를 반환하는 함수(조건)
* 조건이 `true`이면 요소를 결과에 포함, `false`면 제외

---

## 2. 사용 예시

### 배열 필터링

```csharp
int[] numbers = { 1, 2, 3, 4, 5 };

// 짝수만 필터링
var evens = numbers.Where(n => n % 2 == 0);

foreach (var num in evens)
{
    Console.WriteLine(num);
}
// 출력: 2, 4
```

* `n => n % 2 == 0` → 람다식, 짝수인지 판별하는 조건

---

### 딕셔너리 필터링

```csharp
var dict = new Dictionary<string, int>
{
    { "apple", 3 },
    { "banana", 5 },
    { "cherry", 2 }
};

// 값이 3 이상인 항목만
var filtered = dict.Where(pair => pair.Value >= 3);

foreach (var item in filtered)
{
    Console.WriteLine($"{item.Key} = {item.Value}");
}
// 출력:
// apple = 3
// banana = 5
```

---

## 3. 반환 타입과 특징

* 반환 타입은 `IEnumerable<T>` (즉, **지연 실행**됨)
* 결과를 바로 `foreach`로 순회하거나,
  `.ToList()` 또는 `.ToArray()`로 변환 가능

```csharp
var list = numbers.Where(n => n > 2).ToList();
```

---

## 4. 장점

* **원본 데이터 변경 X** → 새로운 시퀀스를 반환
* 조건식을 간단한 **람다식**으로 표현 가능
* **여러 번 체이닝 가능**

```csharp
var result = numbers
    .Where(n => n > 2)
    .Where(n => n % 2 == 0);
```

---

## 5. `Where`와 조건문의 차이

* `if`문은 한 번에 하나의 요소를 조건 체크
* `Where`는 컬렉션 전체를 대상으로 **필터링된 시퀀스**를 반환

---
---

이 코드는 **처음 본 숫자에 대해 딕셔너리에 초기값(0)을 넣어두기 위한 단계**입니다.

```csharp
if (!counts.ContainsKey(num))
{
    counts[num] = 0;   // ← 처음 등장한 키라서 기본값 0으로 초기화
}
counts[num]++;         // 그 다음에 1 증가 (0 → 1)
```

### 왜 초기화가 필요할까?

`Dictionary<TKey, TValue>`에서 **없는 키**를 바로 `counts[num]++`로 증가시키면,

* `counts[num]`을 읽는 순간 **KeyNotFoundException** 이 발생합니다.
  (존재하지 않는 키의 값을 읽을 수 없기 때문)

그래서 **처음 등장한 키**라면 `0`을 넣어 **값을 만들고**, 그 다음에 증가시키는 거예요.

---

## 같은 의도의 다른 안전한 패턴들

초기화 + 증가를 한 줄 또는 다른 방식으로도 쓸 수 있어요.

### 1) `TryGetValue` 사용

```csharp
if (!counts.TryGetValue(num, out int current))
    current = 0;
counts[num] = current + 1;
```

### 2) `GetValueOrDefault` (지원되는 런타임에서)

```csharp
counts[num] = counts.GetValueOrDefault(num) + 1;
```

### 3) `TryAdd`로 먼저 넣고 증가

```csharp
counts.TryAdd(num, 0);
counts[num]++;
```

### 4) (범위가 작을 때) 배열 카운터 사용

값 범위가 제한적이면(예: 0\~999) 아예 배열로:

```csharp
int[] counts = new int[1000];
counts[num]++;  // 배열은 기본값이 0이므로 바로 증가 가능
```

---

## 핵심 요약

* `counts[num] = 0;`는 **처음 본 키를 0으로 초기화**해서
  그 다음 줄의 `counts[num]++`가 **예외 없이 동작**하도록 만들기 위한 코드입니다.
* 없던 키를 바로 읽어 증가시키면 예외가 나므로, **초기화 후 증가**가 안전한 패턴입니다.

---
---

좋은 포인트예요!
아래 한 줄에서

```csharp
var maxItems = counts.Where(pair => pair.Value == maxCount).ToList();
```

`var`를 쓰는 이유와 의미를 **초보자 관점**에서 설명해볼게요.

---

## `var`는 “자동 타입 추론”

* **컴파일러가 오른쪽 표현식으로부터 변수의 타입을 정확히 알아내는 것**이에요.
* 즉, `var`는 **동적 타입**(JavaScript의 `var`처럼)이 아니라 **정적 타입**입니다.
  → 컴파일 시점에 타입이 **딱 결정**되고, 이후 바꿀 수 없어요.

이 줄의 실제 타입은:

```csharp
List<KeyValuePair<int, int>> maxItems =
    counts.Where(pair => pair.Value == maxCount).ToList();
```

와 **완전히 동일**합니다. (`ToList()` 때문에 `List<KeyValuePair<int,int>>`가 됩니다.)

---

## 왜 `var`를 쓰면 좋을까?

1. **긴 제네릭 타입을 안 적어도 됨**
   `List<KeyValuePair<int,int>>`처럼 긴 타입을 매번 쓰는 게 번거롭죠. `var`로 가독성을 높입니다.

2. **오른쪽을 보면 타입이 ‘명확’할 때**
   `...ToList()`를 보면 “리스트구나”가 바로 보여요. 이런 경우 `var`가 코드를 더 읽기 쉽게 합니다.

3. **타입이 바뀌어도 좌변 수정이 줄어듦**
   LINQ 체인을 조금 바꿔서 `ToArray()`로 바꾸면 타입이 `KeyValuePair<int,int>[]`가 되는데, `var`면 좌변을 수정하지 않아도 됩니다.

4. **익명 타입(anonymous type)에는 필수**
   `Select(x => new { ... })` 같은 익명 타입은 타입 이름이 없으므로 `var`를 써야만 합니다.

---

## 오해 방지: `var`는 느슨한 타입이 아니다

* 아래처럼 **다른 타입을 대입하려 하면 컴파일 에러**가 납니다.

  ```csharp
  var maxItems = counts.Where(...).ToList(); // List<KeyValuePair<int,int>>
  maxItems = 3; // ❌ 컴파일 에러 (타입 불일치)
  ```

---

## 이 줄을 `var` 없이 쓰면?

```csharp
List<KeyValuePair<int, int>> maxItems =
    counts.Where(pair => pair.Value == maxCount).ToList();
```

동일하게 동작하지만, **길고 덜 읽기 쉽습니다.**

---

## 언제 `var`, 언제 명시형?

* **타입이 RHS(오른쪽)에서 명확**하면 `var` 권장 (`new`, `ToList()`, `Select(...)` 등)
* **타입이 한눈에 안 보일 때**는 명시적으로 타입을 써서 가독성을 높이세요.

---

### 한 줄 요약

> 이 경우 `var`는 \*\*List\<KeyValuePair\<int,int>>\*\*를 깔끔하게 표현하는 **타입 추론 도우미**라서 쓰는 거예요. 정적 타입이며, 더 짧고 읽기 쉬운 코드가 됩니다.

