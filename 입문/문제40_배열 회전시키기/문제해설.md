

# 🔄 배열 회전시키기 (C#) — 풀이 노트

## 1) 문제 요약

* 정수 배열 `numbers`가 주어진다.
* `direction`이 `"left"`면 **왼쪽으로 한 칸 회전**
* `direction`이 `"right"`면 **오른쪽으로 한 칸 회전**
* 회전된 결과 배열을 반환하라.

---

## 2) 작은 예시로 이해하기

* \[1,2,3], direction="right"
  → 맨 끝(3)이 맨 앞으로 → \[3,1,2]

* \[4,455,6,4,-1,45,6], direction="left"
  → 맨 앞(4)이 맨 뒤로 → \[455,6,4,-1,45,6,4]

👉 핵심: **맨 앞/뒤 원소를 꺼내서 반대편에 붙인다.**

---

## 3) 규칙 정리

* **오른쪽 회전**

  * 마지막 원소 → 맨 앞
  * 나머지 원소들 → 한 칸 뒤로 밀림

* **왼쪽 회전**

  * 첫 번째 원소 → 맨 뒤
  * 나머지 원소들 → 한 칸 앞으로 당겨짐

---

## 4) 사고 과정

1. 결과 배열 크기는 원래와 같다.
2. 방향이 `"right"`이면:

   * result\[0] = numbers\[n-1]
   * result\[i] = numbers\[i-1] (i=1\~n-1)
3. 방향이 `"left"`이면:

   * result\[n-1] = numbers\[0]
   * result\[i] = numbers\[i+1] (i=0\~n-2)

---

## 5) C# 코드 (if문 분기)

```csharp
using System;

public class Solution
{
    public int[] solution(int[] numbers, string direction)
    {
        int n = numbers.Length;
        int[] result = new int[n];

        if (direction == "right")
        {
            result[0] = numbers[n - 1];        // 마지막 → 맨 앞
            for (int i = 1; i < n; i++)
            {
                result[i] = numbers[i - 1];    // 나머지 한 칸씩 뒤로
            }
        }
        else if (direction == "left")
        {
            for (int i = 0; i < n - 1; i++)
            {
                result[i] = numbers[i + 1];    // 나머지 한 칸씩 앞으로
            }
            result[n - 1] = numbers[0];        // 첫 번째 → 맨 뒤
        }

        return result;
    }
}
```

---

## 6) 다른 접근 (LINQ로 간단히)

조금 더 익숙해지면 LINQ를 써서 쉽게도 가능:

```csharp
using System.Linq;

public class Solution
{
    public int[] solution(int[] numbers, string direction)
    {
        return direction == "right"
            ? new int[] { numbers.Last() }.Concat(numbers.Take(numbers.Length - 1)).ToArray()
            : numbers.Skip(1).Concat(new int[] { numbers.First() }).ToArray();
    }
}
```

하지만 초보자 입장에서는 for문으로 직접 작성하는 게 더 직관적임.

---

## 7) 테스트 케이스

* \[1,2,3], "right" → \[3,1,2]
* \[4,455,6,4,-1,45,6], "left" → \[455,6,4,-1,45,6,4]
* \[10,20,30,40], "right" → \[40,10,20,30]
* \[10,20,30,40], "left" → \[20,30,40,10]

---

## 8) 자주 하는 실수

* 맨 앞/뒤 원소 처리를 빼먹고 단순 반복만 쓰는 경우.
* 배열 크기를 넘어가는 인덱스 접근 (IndexOutOfRangeException).
* direction 문자열을 잘못 비교 (대소문자 구분 주의).

---

## ✅ 한 화면 요약

* **문제 핵심**: 맨 앞/뒤 원소를 떼어내 반대쪽에 붙인다.
* **풀이 전략**: if문으로 `"left"`, `"right"` 나눠서 배열 재구성.
* **코드 포인트**: for문에서 인덱스를 한 칸 이동시켜 채우기.

