

# ğŸ”„ ë°°ì—´ íšŒì „ì‹œí‚¤ê¸° (C#) â€” í’€ì´ ë…¸íŠ¸

## 1) ë¬¸ì œ ìš”ì•½

* ì •ìˆ˜ ë°°ì—´ `numbers`ê°€ ì£¼ì–´ì§„ë‹¤.
* `direction`ì´ `"left"`ë©´ **ì™¼ìª½ìœ¼ë¡œ í•œ ì¹¸ íšŒì „**
* `direction`ì´ `"right"`ë©´ **ì˜¤ë¥¸ìª½ìœ¼ë¡œ í•œ ì¹¸ íšŒì „**
* íšŒì „ëœ ê²°ê³¼ ë°°ì—´ì„ ë°˜í™˜í•˜ë¼.

---

## 2) ì‘ì€ ì˜ˆì‹œë¡œ ì´í•´í•˜ê¸°

* \[1,2,3], direction="right"
  â†’ ë§¨ ë(3)ì´ ë§¨ ì•ìœ¼ë¡œ â†’ \[3,1,2]

* \[4,455,6,4,-1,45,6], direction="left"
  â†’ ë§¨ ì•(4)ì´ ë§¨ ë’¤ë¡œ â†’ \[455,6,4,-1,45,6,4]

ğŸ‘‰ í•µì‹¬: **ë§¨ ì•/ë’¤ ì›ì†Œë¥¼ êº¼ë‚´ì„œ ë°˜ëŒ€í¸ì— ë¶™ì¸ë‹¤.**

---

## 3) ê·œì¹™ ì •ë¦¬

* **ì˜¤ë¥¸ìª½ íšŒì „**

  * ë§ˆì§€ë§‰ ì›ì†Œ â†’ ë§¨ ì•
  * ë‚˜ë¨¸ì§€ ì›ì†Œë“¤ â†’ í•œ ì¹¸ ë’¤ë¡œ ë°€ë¦¼

* **ì™¼ìª½ íšŒì „**

  * ì²« ë²ˆì§¸ ì›ì†Œ â†’ ë§¨ ë’¤
  * ë‚˜ë¨¸ì§€ ì›ì†Œë“¤ â†’ í•œ ì¹¸ ì•ìœ¼ë¡œ ë‹¹ê²¨ì§

---

## 4) ì‚¬ê³  ê³¼ì •

1. ê²°ê³¼ ë°°ì—´ í¬ê¸°ëŠ” ì›ë˜ì™€ ê°™ë‹¤.
2. ë°©í–¥ì´ `"right"`ì´ë©´:

   * result\[0] = numbers\[n-1]
   * result\[i] = numbers\[i-1] (i=1\~n-1)
3. ë°©í–¥ì´ `"left"`ì´ë©´:

   * result\[n-1] = numbers\[0]
   * result\[i] = numbers\[i+1] (i=0\~n-2)

---

## 5) C# ì½”ë“œ (ifë¬¸ ë¶„ê¸°)

```csharp
using System;

public class Solution
{
    public int[] solution(int[] numbers, string direction)
    {
        int n = numbers.Length;
        int[] result = new int[n];

        if (direction == "right")
        {
            result[0] = numbers[n - 1];        // ë§ˆì§€ë§‰ â†’ ë§¨ ì•
            for (int i = 1; i < n; i++)
            {
                result[i] = numbers[i - 1];    // ë‚˜ë¨¸ì§€ í•œ ì¹¸ì”© ë’¤ë¡œ
            }
        }
        else if (direction == "left")
        {
            for (int i = 0; i < n - 1; i++)
            {
                result[i] = numbers[i + 1];    // ë‚˜ë¨¸ì§€ í•œ ì¹¸ì”© ì•ìœ¼ë¡œ
            }
            result[n - 1] = numbers[0];        // ì²« ë²ˆì§¸ â†’ ë§¨ ë’¤
        }

        return result;
    }
}
```

---

## 6) ë‹¤ë¥¸ ì ‘ê·¼ (LINQë¡œ ê°„ë‹¨íˆ)

ì¡°ê¸ˆ ë” ìµìˆ™í•´ì§€ë©´ LINQë¥¼ ì¨ì„œ ì‰½ê²Œë„ ê°€ëŠ¥:

```csharp
using System.Linq;

public class Solution
{
    public int[] solution(int[] numbers, string direction)
    {
        return direction == "right"
            ? new int[] { numbers.Last() }.Concat(numbers.Take(numbers.Length - 1)).ToArray()
            : numbers.Skip(1).Concat(new int[] { numbers.First() }).ToArray();
    }
}
```

í•˜ì§€ë§Œ ì´ˆë³´ì ì…ì¥ì—ì„œëŠ” forë¬¸ìœ¼ë¡œ ì§ì ‘ ì‘ì„±í•˜ëŠ” ê²Œ ë” ì§ê´€ì ì„.

---

## 7) í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤

* \[1,2,3], "right" â†’ \[3,1,2]
* \[4,455,6,4,-1,45,6], "left" â†’ \[455,6,4,-1,45,6,4]
* \[10,20,30,40], "right" â†’ \[40,10,20,30]
* \[10,20,30,40], "left" â†’ \[20,30,40,10]

---

## 8) ìì£¼ í•˜ëŠ” ì‹¤ìˆ˜

* ë§¨ ì•/ë’¤ ì›ì†Œ ì²˜ë¦¬ë¥¼ ë¹¼ë¨¹ê³  ë‹¨ìˆœ ë°˜ë³µë§Œ ì“°ëŠ” ê²½ìš°.
* ë°°ì—´ í¬ê¸°ë¥¼ ë„˜ì–´ê°€ëŠ” ì¸ë±ìŠ¤ ì ‘ê·¼ (IndexOutOfRangeException).
* direction ë¬¸ìì—´ì„ ì˜ëª» ë¹„êµ (ëŒ€ì†Œë¬¸ì êµ¬ë¶„ ì£¼ì˜).

---

## âœ… í•œ í™”ë©´ ìš”ì•½

* **ë¬¸ì œ í•µì‹¬**: ë§¨ ì•/ë’¤ ì›ì†Œë¥¼ ë–¼ì–´ë‚´ ë°˜ëŒ€ìª½ì— ë¶™ì¸ë‹¤.
* **í’€ì´ ì „ëµ**: ifë¬¸ìœ¼ë¡œ `"left"`, `"right"` ë‚˜ëˆ ì„œ ë°°ì—´ ì¬êµ¬ì„±.
* **ì½”ë“œ í¬ì¸íŠ¸**: forë¬¸ì—ì„œ ì¸ë±ìŠ¤ë¥¼ í•œ ì¹¸ ì´ë™ì‹œì¼œ ì±„ìš°ê¸°.

