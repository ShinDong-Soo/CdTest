

# 🏀 공 던지기 (C#) — 초보자용 풀이 노트

## 1) 문제 핵심 한 줄

사람이 n명 원형으로 서 있을 때, **1번이 시작**해서 **오른쪽으로 한 명 건너뛰어(+2)** 공을 던진다.
**k번째로 공을 던지는 사람 번호**를 구하라.

---

## 2) 작은 예시로 감 잡기

* numbers = \[1,2,3,4], k=2
  진행: 1(1번째 던짐) → 3(2번째 던짐) → 1(3번째 …) → …
  ⇒ 2번째로 던지는 사람은 **3**

* numbers = \[1,2,3], k=3
  진행: 1 → 3 → 2 → 1 …
  ⇒ 3번째로 던지는 사람은 **2**

**관찰:** 매번 **인덱스가 +2씩** 움직이고, 끝에 가면 **원형으로 돌아간다(나머지 연산)**.

---

## 3) 규칙을 수식으로

* 배열 인덱스가 0부터라고 하면,

  * 시작 인덱스: 0 (1번 사람)
  * k번째로 던지는 사람 인덱스:

    $$
    \text{idx} = (0 + 2 \times (k-1)) \bmod n
    $$
* 최종 답: `numbers[idx]`

> 왜 `(k-1)`?
> 1번째 던질 때는 이동이 0번(+0), 2번째일 때 +2, 3번째일 때 +4 … 이므로 \**2*(k-1)\*\*.

---

## 4) 한 줄 풀이 (시간 O(1))

```csharp
using System;

public class Solution
{
    public int solution(int[] numbers, int k)
    {
        int n = numbers.Length;
        int idx = (2 * (k - 1)) % n;
        return numbers[idx];
    }
}
```

---

## 5) 직관적인 시뮬레이션(반복) 버전

수식을 쓰기 전, 실제로 **두 칸씩 건너뛰며 k-1번 이동**하는 방식.

```csharp
public class Solution
{
    public int solution(int[] numbers, int k)
    {
        int n = numbers.Length;
        int idx = 0;                // 1번 = 인덱스 0
        for (int i = 1; i < k; i++) // 1번째는 이미 idx=0에서 던짐
        {
            idx = (idx + 2) % n;    // 오른쪽으로 한 명 건너뛰기 = +2
        }
        return numbers[idx];
    }
}
```

---

## 6) 자주 하는 실수 & 팁

* **+1이 아니라 +2**로 이동해야 함 (한 명 “건너뛰고” 다음 사람에게 던짐).
* **나머지(%)를 잊으면** 배열 범위를 벗어남 → 원형이므로 반드시 `% n`.
* 시작이 **1번 사람(인덱스 0)** 이라는 점을 잊지 말기.

---

## 7) 테스트로 확인

* \[1,2,3,4], k=2 → 3
* \[1,2,3,4,5,6], k=5 → 3
* \[1,2,3], k=3 → 2

---

## ✅ 요약

* 핵심 수식: `idx = (2*(k-1)) % n`
* 답: `numbers[idx]`
* 이유: 시작 0에서 매번 +2, 원형이므로 `% n`.

---
---

## 왜 꼭 `% n`이 필요할까?

* 매번 **두 칸씩(+2)** 이동하니, k가 커지면 인덱스가 0,1,2…를 넘어 **n 이상**이 됩니다.
* 하지만 실제 게임은 **원형**이므로 `n`을 넘어가면 **처음(0)으로 되감기**가 되어야 해요.
* `% n`은 바로 이 “되감기(랩어라운드)”를 **수학적으로 한 번에** 처리합니다.

> 인덱스 `idx`가 크더라도
> `idx % n` 은 항상 `0 ≤ 값 < n` (배열 범위 안)

---

## 시각적 비유: 시계

* 12시 시계에서 13시는 다시 1시죠?
  → `13 % 12 = 1`
* 똑같이 사람 수가 `n=6`이면, 인덱스 7은 `7 % 6 = 1`이라 **두 번째 사람**을 가리킵니다.

---

## 예시로 확인

`numbers = [1,2,3,4], n=4`, `idx = 2*(k-1)`

| k | 계산한 idx | idx % 4 | 사람 |
| - | ------: | ------: | -- |
| 1 |       0 |       0 | 1번 |
| 2 |       2 |       2 | 3번 |
| 3 |       4 |       0 | 1번 |
| 4 |       6 |       2 | 3번 |
| 5 |       8 |       0 | 1번 |

4명인 원을 한 바퀴(4칸) 돌면 **처음으로 돌아오므로 주기가 4**입니다.
`% 4`가 이 “주기”를 반영해 주는 거예요.

---

## 코드 관점에서의 의미

아래 두 코드는 완전히 같은 효과입니다.

### 1) 나머지 연산으로 한 번에

```csharp
int idx = (2 * (k - 1)) % n;
return numbers[idx];
```

### 2) 수동으로 접어넣기(느리고 장황)

```csharp
int idx = 2 * (k - 1);
while (idx >= n) idx -= n; // n을 계속 빼서 0~n-1로 접기
return numbers[idx];
```

`% n`은 위 while 루프를 **수학적으로 압축**한 표현이에요. 성능·가독성 모두 이점이 큽니다.

---

## 추가 팁 (C#에서의 %)

* 이번 문제에선 `idx`와 `n`이 양수라서 `%` 결과는 **항상 0 이상**입니다.
* 음수에서의 `%`는 언어마다 다를 수 있는데, 여기선 걱정할 필요가 없어요(음수 인덱스가 나오지 않음).

