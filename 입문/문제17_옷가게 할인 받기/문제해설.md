
## 📝 문제 해결 과정 정리

### 1️⃣ 문제 이해하기

* **목표**: 옷 가격에 따라 **다른 할인율**을 적용해서 최종 금액을 구하기.
* **조건**

  1. **50만 원 이상** → **20% 할인**
  2. **30만 원 이상** → **10% 할인**
  3. **10만 원 이상** → **5% 할인**
  4. 그 외 → **할인 없음**
* 할인 후 소수점 이하는 버림(정수 반환)

---

### 2️⃣ 해결 순서 생각하기

1. **할인율 결정**

   * 가격을 비교해 해당 구간의 할인율을 정함.
2. **할인 적용**

   * 할인된 금액 = `price × (1 - 할인율)`
3. **정수 변환**

   * 문제에서 요구하듯 소수점 이하는 버림.

---

### 3️⃣ 조건문 설계하기

* 큰 금액부터 비교하는 것이 효율적 (50만 원 → 30만 원 → 10만 원).
* 이유: **조건에 맞으면 바로 계산 후 종료**할 수 있기 때문.

---

### 4️⃣ 코드 예시

```csharp
public int solution(int price)
{
    if (price >= 500000) // 50만 원 이상
    {
        price = (int)(price * 0.8);
    }
    else if (price >= 300000) // 30만 원 이상
    {
        price = (int)(price * 0.9);
    }
    else if (price >= 100000) // 10만 원 이상
    {
        price = (int)(price * 0.95);
    }
    // 10만 원 미만은 할인 없음

    return price;
}
```

---

### 5️⃣ 초보자 주의 포인트

* **if-else 순서 중요**
  큰 값부터 비교해야 함.
  예) 50만 원인데 10만 원 조건부터 검사하면 잘못된 할인율 적용 가능.
* `(int)` 캐스팅

  * `price * 0.8`은 `double`이 되므로 `(int)`로 변환해 소수점 버리기.
* **10원 단위 조건**은 따로 처리 필요 없음 (문제에서 이미 보장).

---

### 6️⃣ 예시 실행

| price  | 조건 적용  | 계산식             | 결과     |
| ------ | ------ | --------------- | ------ |
| 150000 | 10만 이상 | `150000 × 0.95` | 142500 |
| 580000 | 50만 이상 | `580000 × 0.8`  | 464000 |

---

✅ **정리**

* 조건문 순서를 잘 짜야 한다.
* 형변환 `(int)`를 통해 소수점 버리기.
* 큰 조건부터 검사하는 것이 안전하다.

---
---

`switch`는 **정확한 값**이나 **패턴 매칭**에 유리하고,
이번 문제처럼 **범위 조건**(>= 500000 등)이 있는 경우는 **C# 7 이상**의 `switch` 패턴 매칭을 쓰면 가능합니다.

---

## 📝 switch 패턴 매칭 버전

```csharp
public int solution(int price)
{
    double discountRate = 0;

    switch (price)
    {
        case >= 500000:
            discountRate = 0.20;
            break;
        case >= 300000:
            discountRate = 0.10;
            break;
        case >= 100000:
            discountRate = 0.05;
            break;
        default:
            discountRate = 0;
            break;
    }

    // 할인 적용
    return (int)(price * (1 - discountRate));
}
```

---

### 📌 동작 원리

1. `switch (price)`에서 `case >= 500000` 같은 **패턴 매칭**을 사용.
   → `if (price >= 500000)`와 같은 효과.
2. 각 구간에 맞는 `discountRate`(할인율)를 저장.
3. 마지막에 `price * (1 - 할인율)`로 할인 적용.
4. `(int)` 캐스팅해서 소수점 이하 버림.

---

### 📊 실행 예시

| price  | case 조건        | discountRate | 계산식           | 결과     |
| ------ | -------------- | ------------ | ------------- | ------ |
| 150000 | case >= 100000 | 0.05         | 150000 × 0.95 | 142500 |
| 580000 | case >= 500000 | 0.20         | 580000 × 0.8  | 464000 |
| 90000  | default        | 0            | 90000 × 1     | 90000  |

---

### 📌 초보자가 이해해야 할 포인트

* **switch 패턴 매칭**은 C# 7.0 이상에서 가능.
* `case >= 값`은 조건문처럼 동작.
* 조건이 여러 개일 때 `switch`를 쓰면 가독성이 높아짐.
* 범위 검사 시, **큰 값부터 순서대로** 작성해야 함 (if문과 동일한 이유).

---
---

이번엔 **할인율 테이블(데이터 기반)** 방식으로 풀어볼게요.
이 방법은 `if`나 `switch`를 쓰지 않고,
조건과 할인율을 **데이터로 저장**해 두고 반복문으로 처리합니다.
→ 나중에 할인 정책이 바뀌면 **코드 수정 없이 데이터만 수정**하면 됩니다.

---

## 📝 할인율 테이블 방식

```csharp
public int solution(int price)
{
    // (기준금액, 할인율) 튜플 리스트
    var discountRules = new (int threshold, double rate)[]
    {
        (500000, 0.20),
        (300000, 0.10),
        (100000, 0.05)
    };

    double discountRate = 0;

    foreach (var rule in discountRules)
    {
        if (price >= rule.threshold)
        {
            discountRate = rule.rate;
            break; // 첫 번째로 해당되는 할인율만 적용
        }
    }

    return (int)(price * (1 - discountRate));
}
```

---

### 📌 동작 방식

1. `discountRules` 배열에 **(기준금액, 할인율)** 데이터를 저장.
2. 가격이 `threshold` 이상이면 그에 맞는 할인율 적용.
3. `break`로 가장 높은 할인율만 적용.
4. `(int)`로 변환해 소수점 이하 버림.

---

### 📊 실행 예시

| price  | threshold | rate | 최종 계산식        | 결과     |
| ------ | --------- | ---- | ------------- | ------ |
| 150000 | 100000    | 0.05 | 150000 × 0.95 | 142500 |
| 580000 | 500000    | 0.20 | 580000 × 0.8  | 464000 |
| 90000  | 없음        | 0    | 90000 × 1     | 90000  |

---

### 📌 초보자가 이해해야 할 포인트

* 할인 정책이 바뀔 때 **배열의 값만 수정**하면 됨.
* 조건이 많아져도 코드 길이가 거의 늘어나지 않음.
* 구조를 이해하면 **if문/ switch문보다 유지보수에 유리**.

---
---


# 🧾 요약 비교표

| 기준        | **switch 패턴 매칭**        | **데이터(테이블) 기반**                 |
| --------- | ----------------------- | ------------------------------- |
| 가독성       | 조건이 몇 개 안 되면 **매우 직관적** | 규칙이 많아도 **일관적이고 깔끔**            |
| 유지보수      | 규칙이 바뀔 때 **코드 수정 필요**   | **데이터만 수정** (코드는 그대로)           |
| 확장성       | 조건 늘수록 `case`가 **길어짐**  | 규칙 추가해도 **배열/리스트에 항목만 추가**      |
| 변경 빈도     | **드물게 바뀌는** 룰에 적합       | **자주 바뀌는** 룰(기획/운영) 적합          |
| 테스트       | 단일 함수 로직 테스트 **간단**     | 규칙 세트만 바꿔 **여러 시나리오 쉽게 테스트**    |
| 의존성       | C# 버전(패턴 매칭: C# 7+) 영향  | 일반 문법만 사용 → **버전 영향 적음**        |
| 퍼포먼스      | 분기만 실행 → **아주 빠름**      | 반복문 1회(규칙 수 만큼) → 사실상 **동급**    |
| 설정 분리     | 어려움                     | 규칙을 **Json/DB/Config**로도 분리 가능  |
| 비즈니스 팀 협업 | 개발자 중심                  | **비개발자도 규칙 관리 가능**(데이터만 수정하면 됨) |

---

# 🧠 언제 어떤 방식을 쓰면 좋을까?

## ✅ switch 방식이 좋은 상황

* 규칙이 **3\~5개 이하**로 **고정**이고, 자주 안 바뀜
* 팀에서 **C# 패턴 매칭 문법**에 익숙함
* 코드만 보고도 **즉시 로직을 파악**하고 싶을 때
* 예: 티어가 소수(브론즈/실버/골드)로 고정된 할인 정책

### 예시

```csharp
public int solution(int price)
{
    switch (price)
    {
        case >= 500000: return (int)(price * 0.8);
        case >= 300000: return (int)(price * 0.9);
        case >= 100000: return (int)(price * 0.95);
        default:        return price;
    }
}
```

---

## ✅ 데이터(테이블) 방식이 좋은 상황

* **할인 구간/비율이 자주 바뀜** (운영/기획이 수시 변경)
* 규칙이 **많거나 앞으로 늘어날 가능성**이 큼
* 나중에 **Json/DB/Config**로 분리해 **코드 수정 없이 운영**하고 싶음
* A/B 테스트처럼 **여러 정책을 빠르게 교체**해야 함

### 예시

```csharp
public int solution(int price)
{
    var rules = new (int threshold, double rate)[] {
        (500000, 0.20), (300000, 0.10), (100000, 0.05)
    };

    foreach (var (threshold, rate) in rules)
        if (price >= threshold)
            return (int)(price * (1 - rate));

    return price;
}
```

> 규칙이 바뀌면 `rules`만 바꾸면 끝! (심지어 파일/DB에서 읽어올 수도 있음)

---

# 🔧 실전 팁

* **규칙 수가 적고 고정** → *switch* 먼저 고려
* **규칙이 늘어날/바뀔 가능성** → *데이터 방식*이 장기적으로 이득
* 팀 규모가 커지고 **운영/기획 개입**이 많아질수록 → *데이터 방식* 추천
* 둘 다 가능하면:

  * **개발 초기**: switch로 빠르게
  * **운영 단계**: 데이터 방식으로 리팩토링

---

# ✅ 한 줄 정리

* **switch**: *작고 고정된 룰* → 빠르고 직관적
* **데이터 방식**: *변화 가능성이 크고 확장되는 룰* → 유연하고 유지보수 친화적

