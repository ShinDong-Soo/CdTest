

# 🏥 진료 순서 정하기 (C# 초보자용 정리)

## 1) 문제 핵심 요약

* 환자들의 **응급도 점수 배열 emergency**가 주어진다.
* 응급도가 **높을수록 진료 순서가 앞**이다.
* 각 환자가 몇 번째로 진료를 받을지 순서를 배열로 반환해야 한다.

예시)
`[3, 76, 24] → [3, 1, 2]`
(76이 가장 높으므로 1등, 24는 2등, 3은 3등)

---

## 2) 사고 과정 (풀이 접근 방법)

1. **정렬 기준 파악**

   * 응급도가 **클수록 순위가 앞**이다 → 내림차순 정렬 필요.
2. **순위 매기기 방법 생각**

   * 응급도 배열을 정렬하여 순위를 매긴 뒤, 원래 배열의 순서에 맞게 매핑.
   * 예: 정렬된 배열에서 "내 값이 몇 번째인지" 찾아서 순위로 변환.
3. **구현 방식 선택**

   * (방법 1) **직접 비교하기**: 원소마다 다른 원소와 비교하며 큰 값이 몇 개인지 세서 순위를 정한다. (초보자 친화)
   * (방법 2) **정렬 + 인덱스 활용**: 정렬된 배열을 만든 뒤 원래 값의 순위 찾기. (조금 더 깔끔)

---

## 3) 방법 1: 직접 비교 (for문 이중 반복)

```csharp
public class Solution {
    public int[] solution(int[] emergency) {
        int n = emergency.Length;
        int[] answer = new int[n];

        for (int i = 0; i < n; i++) {
            int rank = 1; // 기본 순위는 1등
            for (int j = 0; j < n; j++) {
                if (emergency[j] > emergency[i]) {
                    rank++; // 나보다 큰 값이 있으면 순위 밀림
                }
            }
            answer[i] = rank;
        }
        return answer;
    }
}
```

* **아이디어**: 나보다 점수가 큰 사람이 몇 명인지 세고, `순위 = 1 + 큰 사람 수`.
* 초보자가 이해하기 가장 쉬운 방법.

---

## 4) 방법 2: 정렬 이용 (Array.Sort)

```csharp
using System;
using System.Linq;

public class Solution {
    public int[] solution(int[] emergency) {
        int[] sorted = emergency.OrderByDescending(x => x).ToArray(); // 내림차순 정렬
        int[] answer = new int[emergency.Length];

        for (int i = 0; i < emergency.Length; i++) {
            int rank = Array.IndexOf(sorted, emergency[i]) + 1; // 위치 + 1 → 순위
            answer[i] = rank;
        }
        return answer;
    }
}
```

* **아이디어**: 정렬된 배열에서 현재 값의 위치를 찾으면 바로 순위.
* 코드가 깔끔하지만 `Array.IndexOf`를 쓸 줄 알아야 함.

---

## 5) 손 계산 예시

* 입력: `[30, 10, 23, 6, 100]`
* 정렬: `[100, 30, 23, 10, 6]`
* 순위 매핑:

  * 30 → 2
  * 10 → 4
  * 23 → 3
  * 6 → 5
  * 100 → 1
* 결과: `[2, 4, 3, 5, 1]`

---

## 6) 자주 하는 실수 체크

* 내림차순 정렬해야 하는데 오름차순으로 하는 경우
* `순위 = 큰 값 개수` 로 착각 (정답은 `1 + 큰 값 개수`)
* 배열 인덱스와 순위를 혼동

---

## ✅ 결론

* **처음 공부할 땐** "이중 for문"으로 직접 순위 세는 방식(방법 1)이 이해하기 쉽다.
* **조금 익숙해지면** "정렬 후 위치 찾기"(방법 2) 방식이 더 효율적이고 깔끔하다.

---
---

### 📌 `rank++`가 하는 일

* `rank`라는 **변수**는 \*\*숫자를 저장하는 공간(메모리 상의 그릇)\*\*입니다.
* `++`는 **1 증가시키기**라는 뜻이에요.
  즉, `rank = rank + 1;` 과 똑같습니다.

---

### 📌 흐름 속에서 `rank`의 변화

```csharp
int rank = 1; // 처음엔 무조건 1등으로 시작
```

* 여기서 `rank`라는 변수가 만들어지고 값 **1**이 들어갑니다.

```csharp
if (emergency[j] > emergency[i]) {
    rank++; // rank = rank + 1;
}
```

* 나보다 응급도가 높은 사람이 나오면 → `rank` 변수 안에 있는 값이 1 증가합니다.
* 이 값은 계속 같은 `rank` 변수 안에 누적 저장돼요.

---

### 📌 마지막에 저장되는 위치

```csharp
answer[i] = rank;
```

* 최종적으로 계산된 `rank` 값은 `answer` 배열의 `i`번째 칸에 복사됩니다.
* 즉:

  * `rank` = 계산 과정에서 계속 변하는 **임시 저장소**
  * `answer[i]` = 그 결과를 **최종 보관하는 저장소**

---

### 📊 예시 (응급도 \[3, 76, 24]) 중 i=0일 때

1. `rank = 1` (시작값)
2. j=1 → (76 > 3) 참 → `rank = 2`
3. j=2 → (24 > 3) 참 → `rank = 3`
4. 최종 → `answer[0] = 3` 저장

---

👉 정리하면,
`rank++`는 **rank라는 변수(임시 저장 공간)** 안에 계속 값을 누적해서 올리고,
최종 결과는 `answer[i]`라는 배열에 **영구 저장**되는 거예요.
