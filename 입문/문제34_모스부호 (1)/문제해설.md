
# 📮 프로그래머스: 모스부호 (1) — C# 풀이 노트

## 1) 문제 요약 (한 줄)

공백으로 구분된 모스부호 문자열을 받아, 각 토큰을 알파벳 소문자로 변환해 이어 붙인 문자열을 만든다.

## 2) 입출력 조건 체크

* 입력: `letter` (길이 1\~1000), 공백으로 모스부호 구분, 시작/끝/연속공백 없음
* 출력: 소문자 알파벳 문자열
* 가정: “해독 불가한 코드 없음” → 예외 처리 최소화 가능

## 3) 예시로 직관 잡기

* `".... . .-.. .-.. ---"` → `"hello"`
* `".--. -.-- - .... --- -."` → `"python"`

**관찰:** 문자 사이가 “하나의 공백”으로만 구분됨 → `Split(' ')`로 정확히 나뉜다.

---

## 4) 문제 해결 전략 (사고 과정)

1. **사실 정리**

   * 모스부호 ↔ 알파벳 매핑이 고정으로 제공된다.
   * 입력은 공백으로 토큰화 가능.

2. **핵심 아이디어**

   * “토큰 단위”로 해석 → 각 토큰을 **빠르게** 알파벳으로 바꾸려면 **사전(Dictionary)** 조회가 가장 직관적이고 O(1)에 가깝다.

3. **대안 아이디어**

   * 문제 하단에 “a\~z 순서의 모스 배열”이 제공됨.
   * 이 배열 인덱스(0\~25)가 ‘a’부터의 오프셋과 일치 → 배열에서 인덱스를 찾아 문자화하는 방법도 가능(하지만 배열에서 역검색이 필요하면 속도가 떨어짐).
   * 결론: **초보자에겐 Dictionary로 직관적 구현 → 통과 후, 배열 버전으로 리팩터링 연습**이 학습에 좋다.

---

## 5) 자료구조 선택 이유

* **Dictionary\<string, char>**

  * 키: 모스 문자열 (예: `"...-"`)
  * 값: 알파벳 문자 (예: `'v'`)
  * 장점: 읽기 쉬움, 구현 간단, 조회 빠름, 유지보수 용이

---

## 6) 알고리즘 설계 (의사코드)

```
morseDict = { ".-":'a', "-...":'b', ... }
tokens = letter.Split(' ')
builder = StringBuilder()
foreach t in tokens:
    builder.Append(morseDict[t])
return builder.ToString()
```

복잡도:

* N = 토큰 개수
* 시간: O(N) (각 토큰 1회 조회)
* 공간: O(1) (고정 크기 사전) + 결과 문자열 길이

---

## 7) C# 코드 (주석 친 버전)

```csharp
using System;
using System.Collections.Generic;
using System.Text;

public class Solution
{
    public string solution(string letter)
    {
        // 1) 모스 → 알파벳 매핑 테이블
        var morse = new Dictionary<string, char>
        {
            [".-"] = 'a',   ["-..."] = 'b', ["-.-."] = 'c', ["-.."] = 'd',  ["."] = 'e',   ["..-."] = 'f',
            ["--."] = 'g',  ["...."] = 'h', [".."] = 'i',   [".---"] = 'j', ["-.-"] = 'k', [".-.."] = 'l',
            ["--"] = 'm',   ["-."] = 'n',   ["---"] = 'o',  [".--."] = 'p', ["--.-"] = 'q',[".-."] = 'r',
            ["..."] = 's',  ["-"] = 't',    ["..-"] = 'u',  ["...-"] = 'v', [".--"] = 'w', ["-..-"] = 'x',
            ["-.--"] = 'y', ["--.."] = 'z'
        };

        // 2) 공백으로 분리 (연속 공백 없음이 보장됨)
        string[] tokens = letter.Split(' ');

        // 3) 빠른 문자열 생성용 StringBuilder
        var sb = new StringBuilder(capacity: tokens.Length);

        // 4) 각 토큰 해석해서 이어 붙이기
        foreach (string token in tokens)
        {
            // 문제 조건상 항상 해독 가능하지만,
            // 안전하게 TryGetValue를 써도 됨 (여기서는 단순화)
            sb.Append(morse[token]);
        }

        // 5) 결과 반환
        return sb.ToString();
    }
}
```

---

## 8) “배열 데이터”로 푸는 대안 (학습용)

> 제공된 배열: `string[] codes = {".-","-...","-.-.","-..",".", ... ,"--.."}`
> 인덱스 0 → 'a', 1 → 'b' … 25 → 'z'

* 역방향(모스→인덱스) 조회가 필요하므로 **배열만** 쓰면 매 토큰마다 선형탐색 → O(26) = 상수지만 비효율적.
* 실용적으로는 “배열 → Dictionary”로 변환 후 동일 로직이 베스트.

```csharp
public string solution_arrayToDict(string letter)
{
    string[] codes = { ".-","-...","-.-.","-..",".","..-.","--.","....","..",
                       ".---","-.-",".-..","--","-.","---",".--.","--.-"," .-.",
                       "...","-","..-","...-",".--","-..-","-.--","--.." };

    // 배열을 Dictionary로 변환
    var map = new Dictionary<string, char>(26);
    for (int i = 0; i < codes.Length; i++)
    {
        map[codes[i]] = (char)('a' + i);
    }

    var sb = new StringBuilder();
    foreach (var token in letter.Split(' '))
        sb.Append(map[token]);

    return sb.ToString();
}
```

---

## 9) 테스트 케이스 (빠른 체크)

* 기본: `".... . .-.. .-.. ---"` → `hello`
* 기본: `".--. -.-- - .... --- -."` → `python`
* 단일 문자: `"."` → `e`
* 가장 긴 토큰 섞기: `"-- .- -.. ."` → `made`
* 전부 같은 문자: `"... ... ..."` → `sss`

---

## 10) 자주 하는 실수 & 예방 팁

* **`Split` 옵션 실수**: 문제는 “연속 공백 없음” 보장 → `Split(' ')`로 충분. (만약 일반화한다면 `StringSplitOptions.RemoveEmptyEntries` 고려)
* **대소문자**: 출력은 **항상 소문자**. 매핑도 소문자로 고정.
* **성능 미세 팁**: 결과 길이가 대략 토큰 수와 같으므로 `StringBuilder` capacity를 `tokens.Length`로 주면 아주 약간 효율적.

---

## 11) 확장 아이디어 (심화)

* **양방향 변환기**: 알파벳→모스, 모스→알파벳을 모두 지원하는 유틸 클래스로 분리
* **단어 단위(슬래시 `/` 사용)** 입력 포맷도 지원하도록 확장
* **예외 처리 강화**: 잘못된 토큰 등장 시 `?`로 표시 등

---

## 12) 한 화면 요약 (면접/포트폴리오용)

* **문제**: 공백으로 구분된 모스부호를 알파벳으로 변환
* **핵심**: `Dictionary<string, char>`로 O(1) 조회, `Split` → `Append`
* **복잡도**: O(N)
* **코드 포인트**: 매핑 테이블 명확성, 간결한 루프, `StringBuilder` 사용
