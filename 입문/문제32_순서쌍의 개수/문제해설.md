

# ✅ 순서쌍의 개수 (C# 초보자용 정리)

## 1) 문제 핵심

* 자연수 `n`에 대해 `a * b = n`을 만족하는 **자연수 순서쌍 (a, b)** 의 개수를 구하라.
* 예) `n=20` → (1,20),(2,10),(4,5),(5,4),(10,2),(20,1) → **6개**

---

## 2) 사고 과정

### 관찰 1: “약수 ↔ 순서쌍” 1:1 대응

* `a`가 `n`의 **약수**라면, `b = n / a`도 자연수.
* 즉, **약수 하나**를 고르면 **순서쌍 (a, n/a)** 이 **딱 1개** 생김.
* 결론: **순서쌍의 개수 = n의 약수의 개수**

### 관찰 2: 약수는 짝으로 등장

* `i`가 약수면 `n/i`도 약수 → 보통 **2개씩** 셈.
* 단, `i*i == n`(완전제곱)인 경우는 **한 번만** 셈.

### 선택지

* 방법 A: 1부터 `n`까지 전부 나눠보는 **O(n)** (느림)
* 방법 B: 1부터 `√n`까지만 체크하는 **O(√n)** (권장)

---

## 3) 풀이 전략 (O(√n))

1. `count = 0`
2. `i = 1`부터 `i * i <= n`까지 반복
3. `n % i == 0`이면:

   * `i * i == n` → `count += 1` (정사각형인 경우)
   * 아니면 `count += 2` (짝 약수 `(i, n/i)`)
4. `count` 반환

---

## 4) C# 코드

```csharp
public class Solution {
    public int solution(int n) {
        int count = 0;
        for (int i = 1; i * i <= n; i++) {
            if (n % i == 0) {
                if (i * i == n) count += 1; // i와 n/i가 같은 한 개
                else count += 2;            // (i, n/i) 두 개
            }
        }
        return count;
    }
}
```

---

## 5) 예시 검증

* `n = 20`

  * 약수 쌍: (1,20),(2,10),(4,5) → 짝으로 3쌍 → **6개**
* `n = 100`

  * √100 = 10
  * i=1,2,4,5,10 → 10은 `i*i==n`이므로 +1, 나머지는 +2
  * 2+2+2+2+1 = **9개**

---

## 6) 추가 지식(선택)

* 소인수분해로도 가능:
  `n = p1^e1 * p2^e2 * ...` 이면 **약수 개수 = (e1+1)(e2+1)…**
  (이번 범위 `n ≤ 1,000,000`에서는 √n 방식이 충분히 빠름)

---

## 7) 자주 하는 실수

* **0 포함**하지 않기: 자연수이므로 a,b는 1 이상.
* 완전제곱수 처리 누락: `i*i==n`일 때 **한 번만** 더해야 함.
* `i*i`가 `int` 범위를 넘는 걱정은 여기선 불필요(조건상 n ≤ 1e6).

---

### 한 줄 요약

> **순서쌍 개수 = 약수 개수**
> → `i=1..√n`에서 나누어떨어지면 `+2`, 단 `i*i==n`이면 `+1`만!

---
---


## 코드 전체

```csharp
public class Solution {
    public int solution(int n) {
        int count = 0;
        for (int i = 1; i * i <= n; i++) {
            if (n % i == 0) {
                if (i * i == n) count += 1; // i와 n/i가 같은 한 개
                else count += 2;            // (i, n/i) 두 개
            }
        }
        return count;
    }
}
```

---

## 한 줄씩 설명

1. `int count = 0;`

* 약수의 총 개수를 담을 **누적 변수**입니다. 처음엔 0에서 시작해요.

2. `for (int i = 1; i * i <= n; i++) { ... }`

* `i`를 1부터 올리며 검사합니다.
* 조건을 `i * i <= n`으로 둔 이유:

  * 어떤 수의 약수 `i`가 √n보다 크다면, 이미 그에 대응하는 **짝 약수** `n / i`가 √n보다 작을 때 발견되어요.
  * 그래서 **√n까지만 보면** 모든 약수를 다 세게 됩니다.
  * 예: n=12일 때 1↔12, 2↔6, 3↔4 (왼쪽 1,2,3은 모두 √12≈3.46 이하)

3. `if (n % i == 0) { ... }`

* `%`는 **나머지 연산자**입니다.
* `n % i == 0`이면 `i`가 `n`을 \*\*딱 나누는 수(약수)\*\*라는 뜻이에요.

4. `if (i * i == n) count += 1;`

* `i`가 `n/i`와 \*\*같은 경우(즉, n이 완전제곱수)\*\*엔 약수가 “하나”만 늘어요.
* 예: n=16, i=4일 때 (4, 16/4=4) → 같은 수이므로 **중복 없이 1개만** 추가.

5. `else count += 2;`

* 그 외의 경우엔 약수가 **쌍으로** 생깁니다: `i`와 `n/i` 두 개를 한 번에 세요.
* 예: n=12, i=3이면 (3, 12/3=4) → **2개** 추가.

6. `return count;`

* 누적된 약수 개수를 반환합니다.

---

## 예시로 이해하기

### 예시 1) n = 12

* i=1: 12%1=0 → (1,12) → `+2` → count=2
* i=2: 12%2=0 → (2,6)  → `+2` → count=4
* i=3: 12%3=0 → (3,4)  → `+2` → count=6
* i=4: `i*i=16>12`이므로 루프 종료
  → 최종 `count = 6` (약수: 1,2,3,4,6,12)

### 예시 2) n = 16 (완전제곱수)

* i=1: 16%1=0 → (1,16) → `+2` → count=2
* i=2: 16%2=0 → (2,8)  → `+2` → count=4
* i=3: 16%3!=0 → 패스
* i=4: 16%4=0, 그리고 `4*4==16` → `+1` → count=5
  → 최종 `count = 5` (약수: 1,2,4,8,16)

---

## 왜 빠른가요? (시간 복잡도)

* 1부터 n까지 모두 확인하면 O(n)이지만,
* 여기선 **1부터 √n까지만** 보니 \*\*O(√n)\*\*입니다. 훨씬 빠르죠!

---

## 작은 팁 (안전한 조건식 대안)

* 현재 조건 `i * i <= n`은 \*\*int 범위의 n(최대 약 21억)\*\*에서 안전합니다(√n 최대 46340여서 곱해도 오버플로우 없음).
* 그래도 더 안전하게 쓰고 싶다면 다음처럼도 자주 씁니다:

  ```csharp
  for (int i = 1; i <= n / i; i++) { ... } // 곱 대신 나눗셈 사용
  ```

  또는

  ```csharp
  int root = (int)Math.Sqrt(n);
  for (int i = 1; i <= root; i++) { ... }
  ```

---

## 보너스 지식

* n=1 → 약수는 {1} 하나이므로 결과 1
* n이 **소수**면 약수는 항상 1과 n, **딱 2개**
* n이 **완전제곱수**면 약수 개수는 **홀수** (중앙에 하나가 겹치므로)

궁금한 n 값 하나 골라주시면, 위 로직이 **어떻게 count를 올리는지** 한 단계씩 표로도 보여드릴게요!
