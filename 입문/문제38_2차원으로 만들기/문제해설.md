

# 🔷 2차원으로 만들기 (C#) — 풀이 노트

## 1) 문제 요약

* 입력: `num_list` (1차원 배열), `n` (정수)
* 출력: `num_list`를 **앞에서부터 n개씩 잘라** 2차원 배열로 변환

예시)

* `[1,2,3,4,5,6,7,8]`, n=2 → `[[1,2],[3,4],[5,6],[7,8]]`

---

## 2) 작은 예시로 이해하기

* 길이가 8, n=2
  → 총 8/2 = 4개의 줄(행) 필요
  → 한 줄에 2개씩 넣는다
* 길이가 9, n=3
  → 총 9/3 = 3개의 줄(행) 필요
  → 한 줄에 3개씩 넣는다

👉 결국 **행 = num\_list.Length / n**, **열 = n** 으로 배열 만들기.

---

## 3) 규칙 정리

* 2차원 배열의 크기: `[행, 열] = [num_list.Length / n, n]`
* `num_list`에서 원소를 차례로 꺼내 `2차원 배열`에 채운다.
* 인덱스 변환:

  * `num_list`의 인덱스 i
  * 2차원 좌표 = `[i / n, i % n]`

---

## 4) 사고 과정

1. 결과 배열을 먼저 준비한다.

   * 행 크기 = `num_list.Length / n`
   * 열 크기 = `n`
   * `int[,] result = new int[행, 열];`
2. 반복문으로 1차원 배열을 돌면서 → 2차원 좌표로 넣는다.

   * i=0 → (0,0)
   * i=1 → (0,1)
   * i=2 → (1,0) … 이런 식.
3. 결과 리턴한다.

---

## 5) C# 코드 (기본 버전)

```csharp
using System;

public class Solution
{
    public int[,] solution(int[] num_list, int n)
    {
        int rows = num_list.Length / n; // 몇 줄?
        int cols = n;                   // 한 줄 크기

        int[,] result = new int[rows, cols];

        for (int i = 0; i < num_list.Length; i++)
        {
            int row = i / n; // 몇 번째 줄
            int col = i % n; // 줄 안에서 몇 번째 칸
            result[row, col] = num_list[i];
        }

        return result;
    }
}
```

---

## 6) List\<List<int>> 버전 (더 직관적인 배열 느낌)

C#에서 `int[,]` 대신 `List<List<int>>` 구조를 쓰면 가변 크기라 더 편할 수도 있음.

```csharp
using System.Collections.Generic;

public class Solution
{
    public List<List<int>> solution(int[] num_list, int n)
    {
        var result = new List<List<int>>();

        for (int i = 0; i < num_list.Length; i += n)
        {
            var row = new List<int>();
            for (int j = 0; j < n; j++)
            {
                row.Add(num_list[i + j]);
            }
            result.Add(row);
        }

        return result;
    }
}
```

---

## 7) 테스트 케이스

* `[1,2,3,4,5,6,7,8], n=2` → `[[1,2],[3,4],[5,6],[7,8]]`
* `[100,95,2,4,5,6,18,33,948], n=3` → `[[100,95,2],[4,5,6],[18,33,948]]`

---

## 8) 자주 하는 실수

* `[,]` (2차원 배열)과 `[][]` (계단형 배열)을 헷갈림.
* i/n, i%n 공식 안 쓰고 직접 if문으로 나눠 쓰다 보면 코드가 복잡해짐.
* `num_list.Length`가 n의 배수라는 조건을 놓치면 IndexOutOfRange 에러 가능.

---

## ✅ 한 화면 요약

* **핵심 규칙**: i번째 원소 → `result[i/n, i%n]`
* **풀이 전략**: 행 = Length/n, 열 = n → 2차원 배열에 채우기
* **코드 포인트**: 인덱스 나눗셈/나머지로 위치 계산

---

👉 이렇게 정리하면 초보자가 “1차원 → 2차원 인덱스 변환”을 확실히 이해할 수 있어요.

혹시 제가 `[,]` (2차원 배열)과 `[][]` (계단형 배열) 차이를 그림으로 정리해드릴까요?


---
---


## 1️⃣ `int[,] result = new int[rows, cols];`

👉 “몇 줄(rows) × 몇 칸(cols)짜리 2차원 상자를 **미리 만든다**”는 뜻이에요.

* `rows` = 행(가로줄, 세로로 몇 줄 있는지)
* `cols` = 열(한 줄에 칸이 몇 개 있는지)

예를 들어 `rows = 3`, `cols = 2`라면:

```
result = [ [0,0],
           [0,0],
           [0,0] ]
```

➡ 아직은 안에 아무 값도 넣지 않았기 때문에, 모두 **0으로 채워진 빈 상자**예요.
(숫자 타입 배열은 자동으로 0으로 초기화됨)

---

## 2️⃣ `result[row, col] = num_list[i];`

👉 방금 만든 빈 상자에 **값을 실제로 넣는 작업**이에요.

* `row` → 몇 번째 줄(상자의 줄 번호)
* `col` → 줄 안에서 몇 번째 칸(상자의 칸 번호)
* `num_list[i]` → 1차원 배열에서 꺼낸 값

즉, `num_list[i]`라는 값을 꺼내서, `result[row, col]` 상자에 채워 넣는 거예요.

---

## 3️⃣ 차이점 요약

| 코드                                     | 하는 일                  | 비유                  |
| -------------------------------------- | --------------------- | ------------------- |
| `int[,] result = new int[rows, cols];` | **빈 2차원 배열을 만든다**     | “3줄 2칸짜리 빈 상자를 만든다” |
| `result[row, col] = num_list[i];`      | **그 상자 안에 값을 채워 넣는다** | “상자 (줄,칸)에 물건을 넣는다” |

---

## 4️⃣ 실제 예시

```csharp
int[] num_list = {1,2,3,4,5,6};
int n = 2;
```

1. 배열 만들기 (`3줄 × 2칸`)

```
result = [ [0,0],
           [0,0],
           [0,0] ]
```

2. 값 채우기

* i=0 → row=0,col=0 → result\[0,0] = 1
* i=1 → row=0,col=1 → result\[0,1] = 2
* i=2 → row=1,col=0 → result\[1,0] = 3
  …

최종:

```
result = [ [1,2],
           [3,4],
           [5,6] ]
```

---

✅ 한마디로 정리하면:

* **첫 번째 줄**(`new int[rows, cols]`)은 “상자만 만든다”
* **두 번째 줄**(`result[row,col] = ...`)은 “상자 안에 물건(값)을 채운다”
