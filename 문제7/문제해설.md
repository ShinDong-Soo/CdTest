---

# 📚 문제 해설: 배열의 원소만큼 추가하기

---

## ✅ 문제 요약

- 빈 배열 `X`가 있습니다.
- 주어진 배열 `arr`의 각 원소 `a`를 **`a`번** 배열 `X`에 추가해야 합니다.
- 그렇게 완성된 배열 `X`를 반환합니다.

---

## ✨ 예시

입력:
```c
arr = [5, 1, 4]
```

**진행 과정:**

| 현재 원소 (a) | 추가 결과 (X)                  |
|:-------------|:-------------------------------|
| 5           | [5, 5, 5, 5, 5]                |
| 1           | [5, 5, 5, 5, 5, 1]             |
| 4           | [5, 5, 5, 5, 5, 1, 4, 4, 4, 4] |

최종 출력:
```c
[5, 5, 5, 5, 5, 1, 4, 4, 4, 4]
```

---

# 🛠 해결 방법 (초보자용 설명)

---

## 1. 먼저, 최종 배열의 크기를 계산한다
- 배열 `arr`를 처음부터 끝까지 보면서
- 각 원소 `a`를 `a`번 추가할 거니까
- **최종 배열의 크기 = `arr[0] + arr[1] + arr[2] + ...`**

```c
int totalLen = 0;
for (size_t i = 0; i < arr_len; i++) {
    totalLen += arr[i];
}
```

---

## 2. 필요한 만큼 메모리를 준비한다 (malloc)
- 크기를 알았으니 메모리를 할당한다.
- malloc을 이용해서 `int`형 배열을 만든다.

```c
int* answer = (int*)malloc(sizeof(int) * totalLen);
```

> 🔥 **malloc은** "동적으로 메모리 공간을 만드는 함수"야.   
> 
> (정확히는, `sizeof(int)`는 `4byte`인데, 그걸 `totalLen`만큼 곱해서 필요한 만큼 메모리를 만드는 거야.)

---

## 3. 배열을 채운다
- 이제 배열 `arr`를 다시 처음부터 읽는다.
- 각 원소 `a`를 `a`번 반복해서 새 배열에 추가한다.

```c
int index = 0;
for (size_t i = 0; i < arr_len; i++) {
    for (int j = 0; j < arr[i]; j++) {
        answer[index++] = arr[i];
    }
}
```

> 🔥 `index++`를 써서 한 칸씩 이동하면서 값을 채우는 거야.

---

## 4. 최종 결과를 반환한다
- 완성된 배열을 반환하면 끝!

```c
return answer;
```

---

# 📌 최종 전체 코드

```c
#include <stdio.h>
#include <stdlib.h>

// arr_len은 배열 arr의 길이입니다.
int* solution(int arr[], size_t arr_len) {
    int totalLen = 0;

    for (size_t i = 0; i < arr_len; i++) {
        totalLen += arr[i];
    }

    int* answer = (int*)malloc(sizeof(int) * totalLen);

    int index = 0;
    for (size_t i = 0; i < arr_len; i++) {
        for (int j = 0; j < arr[i]; j++) {
            answer[index++] = arr[i];
        }
    }

    return answer;
}
```

---

# 🧠 정리 포인트 (깃허브 정리용)

| 개념 | 설명 |
|:---|:---|
| `malloc` | 배열의 크기를 동적으로 미리 계산해서 메모리 공간을 확보함 |
| `for` 반복문 2개 | 외부는 배열 원소를, 내부는 원소 값만큼 반복해서 채움 |
| 반환값 | 완성된 배열을 반환 |
| 주의사항 | `malloc`으로 만든 메모리는 나중에 `free`로 해제해줘야 함 (시험 사이트는 자동으로 해제) |

---

# ✍️ 깃허브에 정리할 때 예시 제목 추천

- **문제명:** 배열의 원소만큼 추가하기
- **주요 개념:** `for` 반복문 중첩, `malloc` 메모리 동적 할당
- **배운 점:** 배열의 길이를 먼저 계산하고, 메모리를 할당한 뒤, 값을 채우는 순서로 접근하는 것이 중요하다.

---

# ✨ 깔끔한 정리 문구 (깃허브용)

> 이 문제를 풀면서 동적 메모리 할당(`malloc`)을 실제로 사용해보았다.  
> 배열의 최종 크기를 미리 계산한 후, 메모리를 확보하고, 각 원소를 지정된 수만큼 반복하여 새로운 배열을 채우는 과정을 구현했다.  
>  
> 특히, 반복문이 두 번 중첩될 때 **바깥 반복문은 원소를 하나씩 읽고**, **안쪽 반복문은 그 값을 여러 번 추가**하는 구조를 이해하는 것이 중요했다.  
>  
> 또한 문제에서 요구한 함수 형태에 맞게 작성해야 하며, `malloc`으로 할당한 메모리는 사이트 채점 시스템에서는 자동으로 관리되지만, 실제 프로젝트에서는 `free`로 메모리 해제까지 해주는 습관이 중요하다.

---

---

# 🔥 마지막으로 질문!

👉 깃허브에 정리할 때  
**"전체 폴더 구조나 파일명 추천"** 도 해줄까?  
(예를 들어 `problems/배열의_원소만큼_추가하기/solution.c` 처럼 폴더로 정리하는 방법)  

필요하면 바로 추가로 정리해줄게! 🚀
해볼까? ✨  
(한 번 깔끔하게 정리하면 나중에 포트폴리오에도 바로 쓸 수 있어!)
